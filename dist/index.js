import o from"fs";import{get as h}from"https";import m from"net";import{spawn as v}from"child_process";import{dirname as d,basename as y}from"path/posix";import{homedir as u}from"os";import{join as l}from"path";import{extract as f}from"tar";import{createHash as E}from"crypto";import P from"adm-zip";var w=l(u(),".cache/weaviate-embedded"),g=l(u(),".local/share/weaviate"),$="latest",c=class{binaryPath;persistenceDataPath;host;port;version;binaryUrl;env;constructor(e){if(this.version&&this.binaryUrl)throw new Error("cannot provide both version and binaryUrl");this.host=e&&e.host?e.host:"127.0.0.1",this.port=e&&e.port?e.port:6789,this.binaryUrl=e?.binaryUrl,this.version=this.parseVersion(e),this.binaryPath=e&&e.binaryPath?e.binaryPath:this.getBinaryPath(e),this.persistenceDataPath=e?.persistenceDataPath?e?.persistenceDataPath:this.getPersistenceDataPath(),this.env=this.parseEnv(e)}parseEnv(e){this.persistenceDataPath||(this.persistenceDataPath=this.getPersistenceDataPath());let t={AUTHENTICATION_ANONYMOUS_ACCESS_ENABLED:"true",QUERY_DEFAULTS_LIMIT:"20",PERSISTENCE_DATA_PATH:this.persistenceDataPath,CLUSTER_HOSTNAME:`Embedded_at_${this.port}`,DEFAULT_VECTORIZER_MODULE:"none",ENABLE_MODULES:"text2vec-openai,text2vec-cohere,text2vec-huggingface,ref2vec-centroid,generative-openai,qna-openai",...process.env};return e&&e.env&&Object.entries(e.env).forEach(([i,r])=>{t[i]=r}),t}parseVersion(e){if(!(e&&e.binaryUrl)){if(!e||!e.version)return $;if(e.version=="latest")return"latest";if(e.version.match(/[1-9]\.[1-9]{2}\..*/g))return e.version;throw new Error(`invalid version: ${e.version}. version must resemble '{major}.{minor}.{patch}, or 'latest'`)}}getBinaryPath(e){let t=process.env.XDG_CACHE_HOME;if(t||(t=w),this.version||(this.version=this.parseVersion(e)),this.binaryUrl){let i=E("md5").update(this.binaryUrl).digest("base64url");return`${t}-${i}`}return`${t}-${this.version}`}getPersistenceDataPath(){let e=process.env.XDG_DATA_HOME;return e||(e=g),e}},p=class{options;pid;constructor(e){this.options=e,this.pid=0,this.ensurePathsExist(),S()}async start(){await this.isListening()&&console.log(`Embedded db already listening @ ${this.options.host}:${this.options.port}`),await this.resolveWeaviateVersion().then(async()=>{await this.ensureWeaviateBinaryExists()}),this.options.env.CLUSTER_GOSSIP_BIND_PORT||(this.options.env.CLUSTER_GOSSIP_BIND_PORT=await D());let e=v(this.options.binaryPath,["--host",this.options.host,"--port",`${this.options.port}`,"--scheme","http"],{env:this.options.env});e.on("error",t=>{console.log(`embedded db failed to start: ${JSON.stringify(t)}`)}),e.stdout.pipe(process.stdout),e.stderr.pipe(process.stderr),this.pid=e.pid,console.log(`Started ${this.options.binaryPath} @ ${this.options.host}:${this.options.port} -- process ID ${this.pid}`),await this.waitTillListening()}stop(){return new Promise((e,t)=>{try{e(process.kill(this.pid,"SIGTERM")),console.log(`Embedded db @ PID ${this.pid} successfully stopped`)}catch{console.log(`Tried to stop embedded db @ PID ${this.pid}.`,"PID not found, so nothing will be done"),e(!1)}})}resolveWeaviateVersion(){return new Promise((e,t)=>{this.options.version=="latest"?h("https://api.github.com/repos/weaviate/weaviate/releases/latest",{headers:{"User-Agent":"Weaviate-Embedded-DB",authorization:`Bearer ${process.env.GITHUB_TOKEN}`}},i=>{let r="";i.on("data",n=>{r+=n}),i.on("end",()=>{if(i.statusCode===200)try{let n=JSON.parse(r);this.options.version=n.tag_name.slice(1),e()}catch(n){t(new Error(`failed to parse latest binary version response: ${JSON.stringify(n)}`))}else t(new Error(`fetch latest binary version, unexpected status code ${i.statusCode}: ${r}`))})}).on("error",i=>{t(new Error(`failed to find latest binary version: ${JSON.stringify(i)}`))}):e()})}async ensureWeaviateBinaryExists(){o.existsSync(`${this.options.binaryPath}`)||(console.log(`Binary ${this.options.binaryPath} does not exist.`,`Downloading binary for version ${this.options.version||this.options.binaryPath}`),await this.downloadBinary().then(async e=>{e.endsWith("tgz")?await this.untarBinary(e):await this.unzipBinary(e)}))}ensurePathsExist(){let e=d(this.options.binaryPath);o.mkdirSync(e,{recursive:!0}),o.mkdirSync(this.options.persistenceDataPath,{recursive:!0})}downloadBinary(){let e=this.buildBinaryUrl(),t;e.endsWith(".zip")?t=`${this.options.binaryPath}.zip`:t=`${this.options.binaryPath}.tgz`;let i=o.createWriteStream(t);return new Promise((r,n)=>{h(e,{headers:{"User-Agent":"Weaviate-Embedded-DB",authorization:`Bearer ${process.env.GITHUB_TOKEN}`}},s=>{s.statusCode==200?(s.pipe(i),i.on("finish",()=>{i.close(),r(t)})):s.statusCode==302&&s.headers.location?h(s.headers.location,{headers:{"User-Agent":"Weaviate-Embedded-DB",authorization:`Bearer ${process.env.GITHUB_TOKEN}`}},b=>{b.pipe(i),i.on("finish",()=>{i.close(),r(t)})}):s.statusCode==404?n(new Error(`failed to download binary: not found. are you sure Weaviate version ${this.options.version} exists? note that embedded db for linux is only supported for versions >= 1.18.0, and embedded db for mac is only supported for versions >= 1.19.8`)):n(new Error(`failed to download binary: unexpected status code: ${s.statusCode}`))}).on("error",s=>{o.unlinkSync(t),n(new Error(`failed to download binary: ${s}`))})})}buildBinaryUrl(){if(this.options.binaryUrl)return this.options.binaryUrl;let e;switch(process.arch){case"arm64":e="arm64";break;case"x64":e="amd64";break;default:throw new Error(`Embedded DB unsupported architecture: ${process.arch}`)}let t="tar.gz";return process.platform=="darwin"&&(t="zip",e="all"),`https://github.com/weaviate/weaviate/releases/download/v${this.options.version}/weaviate-v${this.options.version}-${process.platform}-${e}.${t}`}untarBinary(e){let t=o.createReadStream(e);return new Promise((i,r)=>{t.pipe(f({cwd:d(e),strict:!0}).on("finish",()=>{t.close(),o.unlinkSync(e),o.renameSync(l(d(this.options.binaryPath),"weaviate"),this.options.binaryPath),i(null)}).on("error",n=>{this.options.binaryUrl&&r(new Error(`failed to untar binary: ${n}, are you sure binaryUrl points to a tar file?`)),r(new Error(`failed to untar binary: ${JSON.stringify(n)}`))}))})}unzipBinary(e){let t=new P(e),i=t.getEntries();return new Promise((r,n)=>{i.forEach(s=>{s.entryName=="weaviate"&&(t.extractEntryTo(s.entryName,d(this.options.binaryPath),!1,!0,!1,y(this.options.binaryPath)),o.unlinkSync(e),o.chmodSync(this.options.binaryPath,511),r(null))}),n(new Error("failed to find binary in zip"))})}waitTillListening(){return new Promise((e,t)=>{let i=setTimeout(()=>{clearTimeout(i),clearInterval(r),t(new Error(`failed to connect to embedded db @ ${this.options.host}:${this.options.port}`))},3e4),r=setInterval(()=>{this.isListening().then(n=>{n&&(clearTimeout(i),clearInterval(r),e(null))})},500)})}isListening(){let e=m.connect(this.options.port,this.options.host);return new Promise(t=>{e.on("connect",()=>{console.log("connected to embedded db!"),e.destroy(),t(!0)}).on("error",i=>{console.log("Trying to connect to embedded db...",JSON.stringify(i)),e.destroy(),t(!1)})})}};function S(){let a=process.platform;if(a!="linux"&&a!="darwin")throw new Error(`${a} is not supported with EmbeddedDB`)}function D(){return new Promise((a,e)=>{let t=m.createServer();t.listen(0,()=>{let{port:i}=t.address();i?t.close(()=>a(i.toString())):e(new Error("failed to find open port"))})})}import T from"weaviate-client";var O={client:async function(a,e){return{...await T.connectToLocal(e),embedded:new p(a)}}},M=O;export{p as EmbeddedDB,c as EmbeddedOptions,M as default};
